<!DOCTYPE html>
<html>
<head>
    <title>统一模型 + 逆向求解 (v10 - 最终)</title>
    <style>
        /* 样式保持不变 */
        body { margin: 0; background-color: #111; color: white; }
        canvas { display: block; }
        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            font-family: sans-serif;
            min-width: 350px;
        }
        #controls label, #readouts div { 
            display: block; margin: 10px; 
        }
        #readouts {
            margin-top: 15px;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
        #readouts div {
            font-size: 1.1em;
            color: #8f0; 
        }
        #debug-readout {
            font-size: 0.8em; 
            color: #aaa; 
            line-height: 1.6;
        }
    </style>
</head>
<body>

    <div id="controls">
        <label for="themeSelector">主题风格:</label>
        <select id="themeSelector" style="width: 100%; padding: 5px; margin-bottom: 15px;"></select>

        <label for="underbust">下胸围 (cm): <span id="underbustValue">84</span></label>
        <input type="range" id="underbust" min="30" max="200" value="84" step="1">

        <label for="bustCirc">上胸围 (cm): <span id="bustCircValue">95.99</span></label>
        <input type="range" id="bustCirc" min="84" max="284" value="95.99" step="0.01">

        <div id="readouts">
            <div id="debug-readout">
                <b>统一数学值:</b><br>
                模式 = <span id="modeValue">...</span><br>
                x = <span id="xValue">...</span>, 
                y = <span id="yValue">...</span>, 
                r_A = <span id="r_AValue">...</span>
                <br>
                <b>引擎状态:</b> 求解 shape = <span id="shapeValue">...</span>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.skypack.dev/three@0.136.0/build/three.module.js",
        "three/controls/": "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/",
        "three/utils/": "https://cdn.skypack.dev/three@0.136.0/examples/jsm/utils/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/controls/OrbitControls.js';
        import { mergeBufferGeometries } from 'three/utils/BufferGeometryUtils.js';

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █   全局变量 & 状态管理
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        let scene, camera, renderer, controls;

        const THEMES = {
            spongebob: {
                background: 0x87ceeb, // 天蓝色
                type: 'standard',
                structure: 'tri-part', // 三段式结构
                proportions: { shirt: 0.1, pants: 0.2 },
                body: { color: 0xffe44f, roughness: 0.8, metalness: 0.0 },
                shirt: { color: 0xffffff, roughness: 0.9, metalness: 0.0 },
                pants: { color: 0x966941, roughness: 0.9, metalness: 0.0 },
                eye: { color: 0xffffff, roughness: 0.2, metalness: 0.0 },
                pupil: { color: 0x000000, roughness: 0.0 },
            },
            classic: {
                background: 0x2a2a2a, // 深灰色
                type: 'standard',
                structure: 'uni-body', // 一体式结构
                proportions: { shirt: 0, pants: 0 },
                body: { color: 0x008cff, roughness: 0.5, metalness: 0.1 }, // 蓝色身体
                eye: { color: 0xffffff, roughness: 0.2, metalness: 0.0 }, // 改为白色眼球
                pupil: { color: 0x000000, roughness: 0.1 }, // 改为黑色瞳仁
            },
            toon: {
                background: 0xbde8ff, // 柔和天蓝
                type: 'toon',
                structure: 'tri-part', // 改为三段式
                proportions: { shirt: 0.25, pants: 0.35 }, // 衬衫+裤子比例
                body: { color: 0xffdab9 }, // 柔和肤色
                shirt: { color: 0xffdab9 }, // 改为与身体相同的肤色，实现无衬衫效果
                pants: { color: 0x4a6b96 }, // 牛仔蓝色
                eye: { color: 0xffffff, roughness: 0.1 }, // 保持白色，但让它更光滑以区别于衬衫
                pupil: { color: 0x222222 },
            },
            cyberpunk: {
                background: 0x12081a, // 深紫色
                type: 'standard',
                structure: 'tri-part',
                proportions: { shirt: 0.3, pants: 0.25 },
                body: { color: 0x333333, roughness: 0.4, metalness: 0.8 },
                shirt: { color: 0x222222, roughness: 0.5, metalness: 0.5, emissive: 0xff00ff, emissiveIntensity: 1.5 },
                pants: { color: 0x181818, roughness: 0.8, metalness: 0.2, emissive: 0x00ffff, emissiveIntensity: 1.5 },
                eye: { color: 0xffffff, emissive: 0xff00ff, roughness: 0.1, metalness: 0.1, emissiveIntensity: 2.5 },
                pupil: { color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 3.0 },
            },
            alien: {
                background: 0x05020d, // 深空紫
                type: 'standard',
                structure: 'uni-body',
                proportions: { shirt: 0, pants: 0 },
                body: { color: 0x98fb98, roughness: 0.6, metalness: 0.1 }, // 浅绿色皮肤
                eye: { color: 0x0a0a0a, roughness: 0.05, metalness: 1.0 }, // 乌黑发亮的眼睛
                pupil: { color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 2.0 },
            }
        };

        const DOM = {
            themeSelector: document.getElementById('themeSelector'),
            underbustSlider: document.getElementById('underbust'),
            bustCircSlider: document.getElementById('bustCirc'),
            underbustValue: document.getElementById('underbustValue'),
            bustCircValue: document.getElementById('bustCircValue'),
            modeValue: document.getElementById('modeValue'),
            xValue: document.getElementById('xValue'),
            yValue: document.getElementById('yValue'),
            r_AValue: document.getElementById('r_AValue'),
            shapeValue: document.getElementById('shapeValue'),
        };

        // 常量
        const TORSO_HEIGHT = 40; 
        const SEGMENTS_W = 1, SEGMENTS_H = 1, SEGMENTS_D = 1; 
        const BUST_Y_POS_BASE = TORSO_HEIGHT * 0.25; // 眼睛的基础Y轴位置
        const EYE_Y_OFFSET = 2.0; // 将眼睛整体向下偏移的量
        const BUST_Y_POS = BUST_Y_POS_BASE - EYE_Y_OFFSET;
        const PIECEWISE_THRESHOLD = 50; 
        const PI = Math.PI;
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █   1. 统一的几何引擎 (GEOMETRY_ENGINE)
        // █ █ █   (v10 模型: c=x, r_hemi=x/2, 5x+...)  █ █ █
        // █ █ █   视觉 和 数学 100% 统一            █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const GEOMETRY_ENGINE = {
            
            /**
             * 1. 核心塑形函数 (视觉 + 数学)
             * !! 关键改动: 统一 r_hemi = x/2 !!
             */
            getShapeParams: (shapeValue, x) => {
                const r_hemi = x / 2; // "统一" 模型的底座半径
                
                if (shapeValue < PIECEWISE_THRESHOLD) {
                    // --- 方案A: "球面被切" (c=x) ---
                    const shapeNorm = shapeValue / PIECEWISE_THRESHOLD;
                    const r_max = x * 100; // "很平"
                    const r_min = r_hemi + 0.001; 
                    const r_A = r_max * Math.pow(r_min / r_max, shapeNorm);
                    const h = r_A - Math.sqrt(r_A * r_A - r_hemi * r_hemi);
                    return { 
                        mode: '球面 (c=x)', 
                        r_A: r_A, h: h, y: 0, r_hemi: r_hemi 
                    };
                } else {
                    // --- 方案B: "圆柱+半球" (c=x) ---
                    const shapeNorm = (shapeValue - PIECEWISE_THRESHOLD) / (100 - PIECEWISE_THRESHOLD);
                    // 移除 y_max 上限，让 y 直接与 shapeNorm 成正比
                    const y = shapeNorm * x * 1.5;
                    const h = y + r_hemi;
                    return { 
                        mode: '圆柱 (c=x)', 
                        r_A: r_hemi, h: h, y: y, r_hemi: r_hemi 
                    };
                }
            },

            /**
             * 3. 精确测量函数 (数学)
             * !! 关键改动: 统一的 v10 公式 !!
             */
            calculateBustCircumference: (params, x) => {
                if (params.y === 0) { // '球面被切'
                    const { r_A, r_hemi } = params; // r_hemi = x/2
                    // 您的公式 (A): 5x + (1 * 弧长)
                    // 弧长 = 2 * r_A * asin( (x/2) / r_A ) = 2 * r_A * asin(r_hemi / r_A)
                    const arcLength = 2 * r_A * Math.asin( r_hemi / r_A );
                    return (5 * x) + arcLength; // 修正: 是 1 倍弧长
                } else { // '圆柱+半球'
                    const { y } = params;
                    // 您的公式 (B): 5x + 2y + PI*x/2
                    return (5 * x) + (2 * y) + (PI * x / 2);
                }
            }
        };

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █   2. 求解器 (SOLVER)
        // █ █ █   (与 v9 相同, 但现在调用统一的引擎) █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const SOLVER = {
            findShapeForCirc: (targetCirc, x) => {
                // 1. 首先检查目标值是否在 0-100 的标准范围内
                const params100 = GEOMETRY_ENGINE.getShapeParams(100, x);
                const circAt100 = GEOMETRY_ENGINE.calculateBustCircumference(params100, x);

                if (targetCirc <= circAt100) {
                    // a. 如果在范围内，使用二分查找，精准高效
                    let minShape = 0;
                    let maxShape = 100;
                    for (let i = 0; i < 15; i++) {
                        const midShape = (minShape + maxShape) / 2;
                        const params = GEOMETRY_ENGINE.getShapeParams(midShape, x);
                        const currentCirc = GEOMETRY_ENGINE.calculateBustCircumference(params, x);
                        if (currentCirc < targetCirc) minShape = midShape;
                        else maxShape = midShape;
                    }
                    return (minShape + maxShape) / 2;
                } else {
                    // b. 如果超出范围，直接通过数学公式反向求解 shape > 100 的值
                    // 公式: circ = (5*x) + (2*y) + (PI*x/2)  且  y = ((shape-50)/50) * x * 1.5
                    // 联立求解 shape:
                    const y_target = (targetCirc - (5 * x) - (PI * x / 2)) / 2;
                    const shapeNorm_target = y_target / (x * 1.5);
                    const shape_target = shapeNorm_target * 50 + 50;
                    return shape_target;
                }
            }
        };
        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █   3. 应用主类 (ThreeApp)
        // █ █ █   封装所有状态和逻辑，为React集成做准备 █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        class ThreeApp {
            constructor() {
                this.meshes = {};
                this.materials = {};
                this.currentThemeName = 'spongebob';
                this.appState = {
                    underbust: 68,
                    targetBust: 88,
                    foundShape: 0,
                };

                this._setupScene();
                this.setTheme(this.currentThemeName, true); // isInitial=true
                this._setupGeometry();
                this._setupEventListeners();
                this.updateApp();
                this._animate();
            }

            // --- 主流程 ---
            updateApp() {
                this._updateStateFromUI();
                const params = this._updateGeometries();
                this._updateUIDisplay(params);
            }

            setTheme(themeName, isInitial = false) {
                this.currentThemeName = themeName;
                const theme = THEMES[themeName] || THEMES.spongebob;
                this._setupMaterials(theme);
                this._setupLighting(theme);
                this.scene.background = new THREE.Color(theme.background);

                if (!isInitial) {
                    this._applyMaterials();
                    this._updateVisibility();
                    this.updateApp();
                }
            }

            // --- 私有设置方法 ---
            _setupScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, TORSO_HEIGHT * 0.5, 40);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(this.renderer.domElement);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.target.set(0, BUST_Y_POS, 0);
            }

            _setupGeometry() {
                const boxGeo = new THREE.BoxGeometry(1, 1, 1);
                this.meshes.torsoTop = new THREE.Mesh(boxGeo, this.materials.body);
                this.meshes.torsoShirt = new THREE.Mesh(boxGeo, this.materials.shirt);
                this.meshes.torsoPants = new THREE.Mesh(boxGeo, this.materials.pants);

                this.meshes.leftEyeGroup = new THREE.Group();
                this.meshes.rightEyeGroup = new THREE.Group();
                this.meshes.leftEyeball = new THREE.Mesh(new THREE.BufferGeometry(), this.materials.eye);
                this.meshes.rightEyeball = new THREE.Mesh(new THREE.BufferGeometry(), this.materials.eye);
                this.meshes.leftPupil = new THREE.Mesh(new THREE.CircleGeometry(1, 16), this.materials.pupil);
                this.meshes.rightPupil = new THREE.Mesh(new THREE.CircleGeometry(1, 16), this.materials.pupil);

                this.meshes.leftEyeGroup.add(this.meshes.leftEyeball, this.meshes.leftPupil);
                this.meshes.rightEyeGroup.add(this.meshes.rightEyeball, this.meshes.rightPupil);

                this.scene.add(
                    this.meshes.torsoTop, this.meshes.torsoShirt, this.meshes.torsoPants,
                    this.meshes.leftEyeGroup, this.meshes.rightEyeGroup
                );
                this._updateVisibility();
            }

            _setupEventListeners() {
                const themeSelector = DOM.themeSelector;
                for (const themeName in THEMES) {
                    const option = document.createElement('option');
                    option.value = themeName;
                    option.textContent = themeName.charAt(0).toUpperCase() + themeName.slice(1);
                    themeSelector.appendChild(option);
                }
                themeSelector.value = this.currentThemeName;
                themeSelector.addEventListener('change', (event) => this.setTheme(event.target.value));
                DOM.underbustSlider.addEventListener('input', () => this.updateApp());
                DOM.bustCircSlider.addEventListener('input', () => this.updateApp());
                window.addEventListener('resize', () => this._onWindowResize());
            }

            // --- 私有更新方法 ---
            _updateStateFromUI() {
                this.appState.underbust = parseFloat(DOM.underbustSlider.value);
                const minBust = this.appState.underbust;
                const maxBust = this.appState.underbust + 200;
                DOM.bustCircSlider.min = minBust.toFixed(2);
                DOM.bustCircSlider.max = maxBust.toFixed(2);
                let targetBust = parseFloat(DOM.bustCircSlider.value);
                this.appState.targetBust = Math.max(minBust, Math.min(targetBust, maxBust));
                const x = this.appState.underbust / 6.0;
                this.appState.foundShape = SOLVER.findShapeForCirc(this.appState.targetBust, x);
            }

            _updateGeometries() {
                const x = this.appState.underbust / 6.0;
                const width = 2 * x;
                const halfDepth = x / 2;
                const params = GEOMETRY_ENGINE.getShapeParams(this.appState.foundShape, x);

                this._updateEyeballGeometry(params);
                this._updatePupilGeometry(params);
                this._updateTorsoAppearance(width, x);

                const BUST_X_POS = width * 0.25;
                this.meshes.leftEyeGroup.position.set(-BUST_X_POS, BUST_Y_POS, halfDepth);
                this.meshes.rightEyeGroup.position.set(BUST_X_POS, BUST_Y_POS, halfDepth);

                return params;
            }
            
            _updateEyeballGeometry(params) {
                let bustGeo;
                if (params.mode === '圆柱 (c=x)') {
                    const { y, r_hemi } = params;
                    const cylinderGeo = new THREE.CylinderGeometry(r_hemi, r_hemi, y, 32);
                    const sphereGeo = new THREE.SphereGeometry(r_hemi, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                    cylinderGeo.translate(0, y / 2, 0);
                    sphereGeo.translate(0, y, 0);
                    bustGeo = mergeBufferGeometries([cylinderGeo, sphereGeo]);
                    bustGeo.rotateX(Math.PI / 2);
                } else {
                    const { r_A, r_hemi, h } = params;
                    const thetaLength = Math.asin(r_hemi / r_A);
                    bustGeo = new THREE.SphereGeometry(r_A, 32, 16, 0, Math.PI * 2, 0, thetaLength);
                    bustGeo.rotateX(Math.PI / 2);
                    bustGeo.translate(0, 0, -(r_A - h));
                }
                this.meshes.leftEyeball.geometry.dispose();
                this.meshes.rightEyeball.geometry.dispose();
                this.meshes.leftEyeball.geometry = bustGeo;
                this.meshes.rightEyeball.geometry = bustGeo.clone();
            }

            _updatePupilGeometry(params) {
                const pupilRadius = params.r_hemi * 0.4;
                this.meshes.leftPupil.scale.set(pupilRadius, pupilRadius, 1);
                this.meshes.rightPupil.scale.set(pupilRadius, pupilRadius, 1);
                const pupilZOffset = params.h + 0.1;
                this.meshes.leftPupil.position.z = pupilZOffset;
                this.meshes.rightPupil.position.z = pupilZOffset;
            }

            _updateUIDisplay(params) {
                DOM.underbustValue.textContent = this.appState.underbust.toFixed(0);
                DOM.bustCircValue.textContent = this.appState.targetBust.toFixed(2);
                DOM.modeValue.textContent = params.mode;
                DOM.xValue.textContent = (this.appState.underbust / 6.0).toFixed(2);
                DOM.yValue.textContent = params.y.toFixed(2);
                DOM.r_AValue.textContent = params.r_A.toFixed(2);
                DOM.shapeValue.textContent = this.appState.foundShape.toFixed(2);
            }

            // --- 主题与外观管理 ---
            _setupMaterials(theme) {
                const MaterialClass = theme.type === 'toon' ? THREE.MeshToonMaterial : THREE.MeshStandardMaterial;
                for (const key of ['body', 'shirt', 'pants', 'eye', 'pupil']) {
                    if (theme[key]) {
                        const props = { ...theme[key] };
                        if (key === 'pupil') props.side = THREE.DoubleSide;
                        this.materials[key] = new MaterialClass(props);
                    }
                }
            }
            _setupLighting(theme) {
                this.scene.children.filter(obj => obj.isLight).forEach(light => this.scene.remove(light));
                if (theme.type === 'toon') {
                    const light = new THREE.HemisphereLight(0xffffff, 0x444444, 2.5);
                    light.position.set(0, 100, 0);
                    this.scene.add(light);
                } else {
                    const ambient = new THREE.AmbientLight(0x404040, 2);
                    const light = new THREE.DirectionalLight(0xffffff, 2);
                    light.position.set(10, 30, 50);
                    this.scene.add(ambient, light);
                }
            }
            _applyMaterials() {
                this.meshes.torsoTop.material = this.materials.body;
                this.meshes.torsoShirt.material = this.materials.shirt;
                this.meshes.torsoPants.material = this.materials.pants;
                this.meshes.leftEyeball.material = this.meshes.rightEyeball.material = this.materials.eye;
                this.meshes.leftPupil.material = this.meshes.rightPupil.material = this.materials.pupil;
            }
            _updateVisibility() {
                const theme = THEMES[this.currentThemeName];
                const isTriPart = theme.structure === 'tri-part';
                this.meshes.torsoShirt.visible = isTriPart;
                this.meshes.torsoPants.visible = isTriPart;
            }
            _updateTorsoAppearance(width, x) {
                const theme = THEMES[this.currentThemeName];
                if (theme.structure === 'tri-part') {
                    const shirtHeight = TORSO_HEIGHT * theme.proportions.shirt;
                    const pantsHeight = TORSO_HEIGHT * theme.proportions.pants;
                    const topHeight = TORSO_HEIGHT - shirtHeight - pantsHeight;
                    this.meshes.torsoTop.scale.set(width, topHeight, x);
                    this.meshes.torsoTop.position.y = (shirtHeight + pantsHeight) / 2;
                    this.meshes.torsoShirt.scale.set(width, shirtHeight, x);
                    this.meshes.torsoShirt.position.y = (pantsHeight - topHeight) / 2;
                    this.meshes.torsoPants.scale.set(width, pantsHeight, x);
                    this.meshes.torsoPants.position.y = (-topHeight - shirtHeight) / 2;
                } else {
                    this.meshes.torsoTop.scale.set(width, TORSO_HEIGHT, x);
                    this.meshes.torsoTop.position.y = 0;
                    this.meshes.torsoShirt.scale.set(0, 0, 0);
                    this.meshes.torsoPants.scale.set(0, 0, 0);
                }
            }

            // --- 渲染与事件 ---
            _animate() {
                requestAnimationFrame(() => this._animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
            _onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // 启动应用
        new ThreeApp();
    </script>
</body>
</html>