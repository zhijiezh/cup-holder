<!DOCTYPE html>
<html>
<head>
    <title>视觉/数学 并行版 (v7 - 最终)</title>
    <style>
        /* 样式保持不变 */
        body { margin: 0; background-color: #111; color: white; }
        canvas { display: block; }
        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            font-family: sans-serif;
            min-width: 350px;
        }
        #controls label, #readouts div { 
            display: block; margin: 10px; 
        }
        #readouts {
            margin-top: 15px;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
        #readouts div {
            font-size: 1.1em;
            color: #8f0; /* "计算" 读数的颜色 */
        }
        #visual-readout {
            font-size: 0.8em; 
            color: #aaa; /* "视觉" 调试的颜色 */
        }
    </style>
</head>
<body>

    <div id="controls">
        <label for="underbust">下胸围 (cm): <span id="underbustValue">84</span></label>
        <input type="range" id="underbust" min="60" max="120" value="84" step="1">

        <label for="bustShape">胸部形态 (0-100): <span id="bustShapeValue">20</span></label>
        <input type="range" id="bustShape" min="0" max="100" value="20" step="1">

        <div id="readouts">
            <div>上胸围 (公式): <span id="bustCircumferenceDisplay">...</span> cm</div>
            
            <div id="visual-readout">
                (视觉模式: <span id="modeValue">...</span>, 
                 视觉 r = <span id="rValue">...</span>, 
                 视觉 h = <span id="hValue">...</span>,
                 视觉 y = <span id="yValue">...</span>)
            </div>
        </div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.skypack.dev/three@0.128.0/build/three.module.js",
        "three/controls/": "https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/controls/OrbitControls.js';

        let scene, camera, renderer, controls, material, torsoMesh, torsoGeo;
        let originalPositions; 

        const underbustSlider = document.getElementById('underbust');
        const bustShapeSlider = document.getElementById('bustShape');

        // --- 常量 ---
        const TORSO_HEIGHT = 40; 
        const SEGMENTS_W = 32; 
        const SEGMENTS_H = 48; 
        const SEGMENTS_D = 16; 
        const BUST_Y_POS = TORSO_HEIGHT * 0.25;
        const PIECEWISE_THRESHOLD = 50; 
        const PI = Math.PI;
        const X_DEBUG = 14; // (84 / 6)

        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █ █ █   1. 视觉引擎 (VISUAL_ENGINE)   █ █ █
        // █ █ █   (v6 模型: c=x, 4x+...)        █ █ █
        // █ █ █   只负责您 "看到" 的 3D 模型        █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const VISUAL_ENGINE = {
            
            getShapeParams: (shapeValue, x) => {
                const r_hemi = x / 2; // "视觉" 模型的底座半径
                if (shapeValue < PIECEWISE_THRESHOLD) {
                    // --- 方案A: "球面被切" (c=x) ---
                    const shapeNorm = shapeValue / PIECEWISE_THRESHOLD;
                    const r_max = x * 100;
                    const r_min = r_hemi + 0.001; 
                    const r_A = r_max * Math.pow(r_min / r_max, shapeNorm);
                    const h = r_A - Math.sqrt(r_A * r_A - r_hemi * r_hemi);
                    return { mode: '视觉 (球面 c=x)', r_A: r_A, h: h, y: 0, r_hemi: r_hemi };
                } else {
                    // --- 方案B: "圆柱+半球" (c=x) ---
                    const shapeNorm = (shapeValue - PIECEWISE_THRESHOLD) / (100 - PIECEWISE_THRESHOLD);
                    const y = shapeNorm * (x * 1.5); // y_max
                    const h = y + r_hemi;
                    return { mode: '视觉 (圆柱 c=x)', r_A: r_hemi, h: h, y: y, r_hemi: r_hemi };
                }
            },

            calculateDisplacement: (ox, oy, x, width, params) => {
                // "视觉" 模型的中心点是重叠的
                const BUST_X_POS = width * 0.25; // x/2
                const leftCenter = { x: -BUST_X_POS, y: BUST_Y_POS };
                const rightCenter = { x: BUST_X_POS, y: BUST_Y_POS };
                
                const distLeft = Math.hypot(ox - leftCenter.x, oy - leftCenter.y);
                const distRight = Math.hypot(ox - rightCenter.x, oy - rightCenter.y);
                let zL = 0, zR = 0;
                
                if (params.y === 0) { // '球面被切'
                    const { r_A, h, r_hemi } = params;
                    if (distLeft < r_hemi) zL = Math.sqrt(r_A*r_A - distLeft*distLeft) - r_A + h;
                    if (distRight < r_hemi) zR = Math.sqrt(r_A*r_A - distRight*distRight) - r_A + h;
                } else { // '圆柱+半球'
                    const { y, r_hemi } = params;
                    if (distLeft < r_hemi) zL = y + (Math.sqrt(r_hemi*r_hemi - distLeft*distLeft));
                    if (distRight < r_hemi) zR = y + (Math.sqrt(r_hemi*r_hemi - distRight*distRight));
                }
                return Math.max(zL, zR);
            }
        };

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █ █ █   2. 计算引擎 (CALCULATION_ENGINE)   █ █ █
        // █ █ █   (v5 模型: c=x/4, 5x+...)         █ █ █
        // █ █ █   只负责您 "读到" 的 UI 数字         █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const CALCULATION_ENGINE = {

            getShapeParams: (shapeValue, x) => {
                const r_hemi = x / 4; // "计算" 模型的底座半径
                if (shapeValue < PIECEWISE_THRESHOLD) {
                    // --- 方案A: "球面被切" (c=x/4) ---
                    const shapeNorm = shapeValue / PIECEWISE_THRESHOLD;
                    const r_max = x * 100; 
                    const r_min = r_hemi + 0.001; 
                    const r_A = r_max * Math.pow(r_min / r_max, shapeNorm);
                    return { r_A: r_A, y: 0, r_hemi: r_hemi };
                } else {
                    // --- 方案B: "圆柱+半球" (c=x/4) ---
                    const shapeNorm = (shapeValue - PIECEWISE_THRESHOLD) / (100 - PIECEWISE_THRESHOLD);
                    const y = shapeNorm * (x * 1.5); // y_max
                    return { r_A: r_hemi, y: y, r_hemi: r_hemi };
                }
            },

            calculateBustCircumference: (params, x) => {
                if (params.y === 0) { // '球面被切'
                    const { r_A, r_hemi } = params; // r_hemi = x/4
                    // 您的公式 (A): 5x + 2 * (弧长)
                    const arcLength = 2 * r_A * Math.asin( r_hemi / r_A );
                    return (5 * x) + (2 * arcLength);
                } else { // '圆柱+半球'
                    const { y } = params;
                    // 您的公式 (B): 5x + 2y + PI*x/2
                    return (5 * x) + (2 * y) + (PI * x / 2);
                }
            }
        };
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █ █ █   (引擎 结束)   █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        
        // ... init() 函数, 与 v5 相同 ...
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, TORSO_HEIGHT * 0.5, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambient);
            const light = new THREE.DirectionalLight(0xffffff, 2);
            light.position.set(10, 30, 50);
            scene.add(light);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, BUST_Y_POS, 0);
            controls.update();

            material = new THREE.MeshStandardMaterial({
                color: 0x008cff,
                roughness: 0.5,
                wireframe: false 
            });

            torsoGeo = new THREE.BoxGeometry(
                1, 1, 1, 
                SEGMENTS_W, SEGMENTS_H, SEGMENTS_D
            );
            originalPositions = torsoGeo.attributes.position.array.slice();

            torsoMesh = new THREE.Mesh(torsoGeo, material);
            scene.add(torsoMesh);

            underbustSlider.addEventListener('input', updateModel);
            bustShapeSlider.addEventListener('input', updateModel);
            
            updateModel();
            animate();
        }


        /**
         * 4. 统一的更新函数 (高性能)
         * !! 关键改动: 同时调用两个引擎 !!
         */
        function updateModel() {
            // 1. 读取输入
            const underbust = parseFloat(underbustSlider.value);
            const shapeValue = parseFloat(bustShapeSlider.value);
            
            // 2. 计算躯干尺寸
            const x = underbust / 6.0; 
            const width = 2 * x;       
            
            // 3. !! 核心 !! 
            //    并行运行两个引擎
            const visualParams = VISUAL_ENGINE.getShapeParams(shapeValue, x);
            const mathParams = CALCULATION_ENGINE.getShapeParams(shapeValue, x);
            
            // 4. 应用 "视觉" 引擎到 3D 模型
            const positions = torsoGeo.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const base_ox = originalPositions[i];
                const base_oy = originalPositions[i + 1];
                const base_oz = originalPositions[i + 2];

                const ox = base_ox * width;
                const oy = base_oy * TORSO_HEIGHT;
                const oz = base_oz * x;
                let zOffset = 0;
                
                if (base_oz > 0.499) { 
                    zOffset = VISUAL_ENGINE.calculateDisplacement(ox, oy, x, width, visualParams);
                }
                
                positions[i] = ox;
                positions[i + 1] = oy;
                positions[i + 2] = oz + zOffset;
            }

            // 5. 通知 Three.js 更新
            torsoGeo.attributes.position.needsUpdate = true;
            torsoGeo.computeVertexNormals();
            torsoGeo.computeBoundingSphere(); 

            // 6. 应用 "计算" 引擎到 UI 读数
            const circumference = CALCULATION_ENGINE.calculateBustCircumference(mathParams, x);
            
            // 7. 更新所有 UI
            document.getElementById('underbustValue').textContent = underbust;
            document.getElementById('bustShapeValue').textContent = shapeValue;
            
            // 这是您要的 "计算" 读数
            document.getElementById('bustCircumferenceDisplay').textContent = circumference.toFixed(2);
            
            // 这是 "视觉" 模型的调试信息
            document.getElementById('modeValue').textContent = visualParams.mode;
            document.getElementById('rValue').textContent = visualParams.r_A.toFixed(2);
            document.getElementById('hValue').textContent = visualParams.h.toFixed(2);
            document.getElementById('yValue').textContent = visualParams.y.toFixed(2);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- 启动 ---
        init();
    </script>
</body>
</html>