<!DOCTYPE html>
<html>
<head>
    <title>统一模型 + 逆向求解 (v10 - 最终)</title>
    <style>
        /* 样式保持不变 */
        body { margin: 0; background-color: #111; color: white; }
        canvas { display: block; }
        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            font-family: sans-serif;
            min-width: 350px;
        }
        #controls label, #readouts div { 
            display: block; margin: 10px; 
        }
        #readouts {
            margin-top: 15px;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
        #readouts div {
            font-size: 1.1em;
            color: #8f0; 
        }
        #debug-readout {
            font-size: 0.8em; 
            color: #aaa; 
            line-height: 1.6;
        }
    </style>
</head>
<body>

    <div id="controls">
        <label for="underbust">下胸围 (cm): <span id="underbustValue">84</span></label>
        <input type="range" id="underbust" min="30" max="200" value="84" step="1">

        <label for="bustCirc">上胸围 (cm): <span id="bustCircValue">95.99</span></label>
        <input type="range" id="bustCirc" min="84" max="284" value="95.99" step="0.01">

        <div id="readouts">
            <div id="debug-readout">
                <b>统一数学值:</b><br>
                模式 = <span id="modeValue">...</span><br>
                x = <span id="xValue">...</span>, 
                y = <span id="yValue">...</span>, 
                r_A = <span id="r_AValue">...</span>
                <br>
                <b>引擎状态:</b> 求解 shape = <span id="shapeValue">...</span>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.skypack.dev/three@0.136.0/build/three.module.js",
        "three/controls/": "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/",
        "three/utils/": "https://cdn.skypack.dev/three@0.136.0/examples/jsm/utils/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/controls/OrbitControls.js';
        import { mergeBufferGeometries } from 'three/utils/BufferGeometryUtils.js';

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █   全局变量 & 状态管理
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        let scene, camera, renderer, controls;
        let torsoMesh, leftBustMesh, rightBustMesh;
        let torsoGeo, material;
        let originalPositions; 

        const DOM = {
            underbustSlider: document.getElementById('underbust'),
            bustCircSlider: document.getElementById('bustCirc'),
            underbustValue: document.getElementById('underbustValue'),
            bustCircValue: document.getElementById('bustCircValue'),
            modeValue: document.getElementById('modeValue'),
            xValue: document.getElementById('xValue'),
            yValue: document.getElementById('yValue'),
            r_AValue: document.getElementById('r_AValue'),
            shapeValue: document.getElementById('shapeValue'),
        };

        // 常量
        const TORSO_HEIGHT = 40; 
        const SEGMENTS_W = 1, SEGMENTS_H = 1, SEGMENTS_D = 1; 
        const BUST_Y_POS = TORSO_HEIGHT * 0.25;
        const PIECEWISE_THRESHOLD = 50; 
        const PI = Math.PI;

        // 应用状态
        const APP_STATE = {
            underbust: 68,
            targetBust: 88,
            foundShape: 0,
        };

        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █ █ █   1. 统一的几何引擎 (GEOMETRY_ENGINE)   █ █ █
        // █ █ █   (v10 模型: c=x, r_hemi=x/2, 5x+...)  █ █ █
        // █ █ █   视觉 和 数学 100% 统一            █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const GEOMETRY_ENGINE = {
            
            /**
             * 1. 核心塑形函数 (视觉 + 数学)
             * !! 关键改动: 统一 r_hemi = x/2 !!
             */
            getShapeParams: (shapeValue, x) => {
                const r_hemi = x / 2; // "统一" 模型的底座半径
                
                if (shapeValue < PIECEWISE_THRESHOLD) {
                    // --- 方案A: "球面被切" (c=x) ---
                    const shapeNorm = shapeValue / PIECEWISE_THRESHOLD;
                    const r_max = x * 100; // "很平"
                    const r_min = r_hemi + 0.001; 
                    const r_A = r_max * Math.pow(r_min / r_max, shapeNorm);
                    const h = r_A - Math.sqrt(r_A * r_A - r_hemi * r_hemi);
                    return { 
                        mode: '球面 (c=x)', 
                        r_A: r_A, h: h, y: 0, r_hemi: r_hemi 
                    };
                } else {
                    // --- 方案B: "圆柱+半球" (c=x) ---
                    const shapeNorm = (shapeValue - PIECEWISE_THRESHOLD) / (100 - PIECEWISE_THRESHOLD);
                    const y_max = x * 1.5;
                    const y = shapeNorm * y_max;
                    const h = y + r_hemi;
                    return { 
                        mode: '圆柱 (c=x)', 
                        r_A: r_hemi, h: h, y: y, r_hemi: r_hemi 
                    };
                }
            },

            /**
             * 3. 精确测量函数 (数学)
             * !! 关键改动: 统一的 v10 公式 !!
             */
            calculateBustCircumference: (params, x) => {
                if (params.y === 0) { // '球面被切'
                    const { r_A, r_hemi } = params; // r_hemi = x/2
                    // 您的公式 (A): 5x + (1 * 弧长)
                    // 弧长 = 2 * r_A * asin( (x/2) / r_A ) = 2 * r_A * asin(r_hemi / r_A)
                    const arcLength = 2 * r_A * Math.asin( r_hemi / r_A );
                    return (5 * x) + arcLength; // 修正: 是 1 倍弧长
                } else { // '圆柱+半球'
                    const { y } = params;
                    // 您的公式 (B): 5x + 2y + PI*x/2
                    return (5 * x) + (2 * y) + (PI * x / 2);
                }
            }
        };

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █ █ █   2. 求解器 (SOLVER)   █ █ █
        // █ █ █   (与 v9 相同, 但现在调用统一的引擎) █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const SOLVER = {
            findShapeForCirc: (targetCirc, x) => {
                let minShape = 0;
                let maxShape = 100;
                let bestShape = 0;
                for (let i = 0; i < 15; i++) {
                    const midShape = (minShape + maxShape) / 2;
                    bestShape = midShape;
                    
                    // !! 关键: 调用统一的引擎 !!
                    const params = GEOMETRY_ENGINE.getShapeParams(midShape, x);
                    const currentCirc = GEOMETRY_ENGINE.calculateBustCircumference(params, x);

                    if (currentCirc < targetCirc) {
                        minShape = midShape;
                    } else {
                        maxShape = midShape;
                    }
                }
                return bestShape;
            }
        };
        
        /**
         * 主更新函数，负责协调所有更新
         */
        function updateApp() {
            updateStateFromUI();
            const params = updateGeometries();
            updateUIDisplay(params);
        }

        /**
         * 从UI滑块读取输入并更新应用状态
         */
        function updateStateFromUI() {
            APP_STATE.underbust = parseFloat(DOM.underbustSlider.value);

            // 约束上胸围滑块范围
            const minBust = APP_STATE.underbust;
            const maxBust = APP_STATE.underbust + 200;
            DOM.bustCircSlider.min = minBust.toFixed(2);
            DOM.bustCircSlider.max = maxBust.toFixed(2);

            // 读取并约束上胸围值
            let targetBust = parseFloat(DOM.bustCircSlider.value);
            APP_STATE.targetBust = Math.max(minBust, Math.min(targetBust, maxBust));

            // 运行求解器
            const x = APP_STATE.underbust / 6.0;
            APP_STATE.foundShape = SOLVER.findShapeForCirc(APP_STATE.targetBust, x);
        }

        /**
         * 根据当前状态更新所有3D几何体
         */
        function updateGeometries() {
            const x = APP_STATE.underbust / 6.0;
            const width = 2 * x;
            const halfDepth = x / 2;

            // 获取统一参数
            const params = GEOMETRY_ENGINE.getShapeParams(APP_STATE.foundShape, x);

            // --- 更新胸部几何体 ---
            const BUST_X_POS = width * 0.25;
            let bustGeo;

            if (params.mode === '圆柱 (c=x)') {
                // --- 大胸模式: 使用独立的几何体 ---
                const { y, r_hemi } = params;

                // a. 创建圆柱和半球
                const cylinderGeo = new THREE.CylinderGeometry(r_hemi, r_hemi, y, 32);
                const sphereGeo = new THREE.SphereGeometry(r_hemi, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                
                // b. 定位并合并
                cylinderGeo.translate(0, y / 2, 0);
                sphereGeo.translate(0, y, 0);
                bustGeo = mergeBufferGeometries([cylinderGeo, sphereGeo]);
                
                // c. 旋转使其朝向前方 (Z轴)
                bustGeo.rotateX(Math.PI / 2);

            } else {
                // 小胸模式: 使用球帽几何体
                const { r_A, r_hemi, h } = params;
                
                // 计算球帽的角度
                const thetaLength = Math.asin(r_hemi / r_A);

                // b. 创建球帽几何体
                bustGeo = new THREE.SphereGeometry(r_A, 32, 16, 0, Math.PI * 2, 0, thetaLength);
                
                // c. 旋转并定位，使其底部与身体表面对齐
                bustGeo.rotateX(Math.PI / 2); // 使其朝向前方 (Z轴)
                bustGeo.translate(0, 0, -(r_A - h)); // 将球帽的"底面"移动到 Z=0 平面
            }

            // 统一更新胸部 Mesh
            leftBustMesh.geometry.dispose();
            rightBustMesh.geometry.dispose();
            leftBustMesh.geometry = bustGeo;
            rightBustMesh.geometry = bustGeo.clone();
            leftBustMesh.position.set(-BUST_X_POS, BUST_Y_POS, halfDepth);
            rightBustMesh.position.set(BUST_X_POS, BUST_Y_POS, halfDepth);

            // --- 更新躯干模型 (简单的长方体) ---
            const positions = torsoGeo.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const base_ox = originalPositions[i];
                const base_oy = originalPositions[i + 1];
                const base_oz = originalPositions[i + 2];

                positions[i] = base_ox * width;
                positions[i + 1] = base_oy * TORSO_HEIGHT;
                positions[i + 2] = base_oz * x;
            }

            torsoGeo.attributes.position.needsUpdate = true;
            torsoMesh.geometry.computeVertexNormals();

            return params; // 将参数传出给UI更新函数
        }

        /**
         * 根据计算结果更新页面上的所有文本读数
         */
        function updateUIDisplay(params) {
            DOM.underbustValue.textContent = APP_STATE.underbust.toFixed(0);
            DOM.bustCircValue.textContent = APP_STATE.targetBust.toFixed(2);
            
            DOM.modeValue.textContent = params.mode;
            DOM.xValue.textContent = (APP_STATE.underbust / 6.0).toFixed(2);
            DOM.yValue.textContent = params.y.toFixed(2);
            DOM.r_AValue.textContent = params.r_A.toFixed(2);
            DOM.shapeValue.textContent = APP_STATE.foundShape.toFixed(2);
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █   初始化 & 渲染循环
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        function setupScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, TORSO_HEIGHT * 0.5, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0x404040, 2);
            const light = new THREE.DirectionalLight(0xffffff, 2);
            light.position.set(10, 30, 50);
            scene.add(ambient, light);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, BUST_Y_POS, 0);
        }

        function setupGeometry() {
            material = new THREE.MeshStandardMaterial({
                color: 0x008cff,
                roughness: 0.5,
                wireframe: false 
            });

            torsoGeo = new THREE.BoxGeometry(1, 1, 1, SEGMENTS_W, SEGMENTS_H, SEGMENTS_D);
            originalPositions = torsoGeo.attributes.position.array.slice();
            torsoMesh = new THREE.Mesh(torsoGeo, material);

            leftBustMesh = new THREE.Mesh(new THREE.BufferGeometry(), material);
            rightBustMesh = new THREE.Mesh(new THREE.BufferGeometry(), material);

            scene.add(torsoMesh, leftBustMesh, rightBustMesh);
        }

        function setupEventListeners() {
            DOM.underbustSlider.addEventListener('input', updateApp);
            DOM.bustCircSlider.addEventListener('input', updateApp);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function init() {
            setupScene();
            setupGeometry();
            setupEventListeners();
            updateApp(); // 首次运行
            animate();
        }

        init();
    </script>
</body>
</html>