<!DOCTYPE html>
<html>
<head>
    <title>逆向求解 并行版 (v9.1 - 完整调试)</title>
    <style>
        /* 样式保持不变 */
        body { margin: 0; background-color: #111; color: white; }
        canvas { display: block; }
        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            font-family: sans-serif;
            min-width: 350px;
        }
        #controls label, #readouts div { 
            display: block; margin: 10px; 
        }
        #readouts {
            margin-top: 15px;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
        #readouts div {
            font-size: 1.1em;
            color: #8f0; 
        }
        #debug-readout {
            font-size: 0.8em; 
            color: #aaa; 
            line-height: 1.6;
        }
    </style>
</head>
<body>

    <div id="controls">
        <label for="underbust">下胸围 (cm): <span id="underbustValue">84</span></label>
        <input type="range" id="underbust" min="60" max="120" value="84" step="1">

        <label for="bustCirc">上胸围 (cm): <span id="bustCircValue">89.14</span></label>
        <input type="range" id="bustCirc" min="84" max="160" value="89.14" step="0.01">

        <div id="readouts">
            <div id="debug-readout">
                <b>数学值 (您的公式):</b><br>
                x = <span id="xValue">...</span>, 
                y = <span id="math_y">...</span>, 
                r_A = <span id="math_r_A">...</span>
                <br>
                <b>引擎状态:</b><br>
                求解 shape = <span id="shapeValue">...</span>, 
                视觉模式 = <span id="modeValue">...</span>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.skypack.dev/three@0.128.0/build/three.module.js",
        "three/controls/": "https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/controls/OrbitControls.js';

        let scene, camera, renderer, controls, material, torsoMesh, torsoGeo;
        let originalPositions; 

        const underbustSlider = document.getElementById('underbust');
        const bustCircSlider = document.getElementById('bustCirc');

        // ... (常量) ...
        const TORSO_HEIGHT = 40; 
        const SEGMENTS_W = 32, SEGMENTS_H = 48, SEGMENTS_D = 16; 
        const BUST_Y_POS = TORSO_HEIGHT * 0.25;
        const PIECEWISE_THRESHOLD = 50; 
        const PI = Math.PI;

        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █ █ █   1. 视觉引擎 (VISUAL_ENGINE)   █ █ █
        // █ █ █   (v6 模型: c=x) - 只负责 "看"   █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const VISUAL_ENGINE = {
            getShapeParams: (shapeValue, x) => {
                const r_hemi = x / 2; // "视觉" 模型的底座半径
                if (shapeValue < PIECEWISE_THRESHOLD) {
                    const shapeNorm = shapeValue / PIECEWISE_THRESHOLD;
                    const r_max = x * 100, r_min = r_hemi + 0.001; 
                    const r_A = r_max * Math.pow(r_min / r_max, shapeNorm);
                    const h = r_A - Math.sqrt(r_A * r_A - r_hemi * r_hemi);
                    return { mode: '球面 (c=x)', r_A: r_A, h: h, y: 0, r_hemi: r_hemi };
                } else {
                    const shapeNorm = (shapeValue - PIECEWISE_THRESHOLD) / (100 - PIECEWISE_THRESHOLD);
                    const y = shapeNorm * (x * 1.5); 
                    const h = y + r_hemi;
                    return { mode: '圆柱 (c=x)', r_A: r_hemi, h: h, y: y, r_hemi: r_hemi };
                }
            },
            calculateDisplacement: (ox, oy, x, width, params) => {
                const BUST_X_POS = width * 0.25; // x/2
                const leftCenter = { x: -BUST_X_POS, y: BUST_Y_POS };
                const rightCenter = { x: BUST_X_POS, y: BUST_Y_POS };
                const distLeft = Math.hypot(ox - leftCenter.x, oy - leftCenter.y);
                const distRight = Math.hypot(ox - rightCenter.x, oy - rightCenter.y);
                let zL = 0, zR = 0;
                
                if (params.y === 0) {
                    const { r_A, h, r_hemi } = params;
                    if (distLeft < r_hemi) zL = Math.sqrt(r_A*r_A - distLeft*distLeft) - r_A + h;
                    if (distRight < r_hemi) zR = Math.sqrt(r_A*r_A - distRight*distRight) - r_A + h;
                } else {
                    const { y, r_hemi } = params;
                    if (distLeft < r_hemi) zL = y + (Math.sqrt(r_hemi*r_hemi - distLeft*distLeft));
                    if (distRight < r_hemi) zR = y + (Math.sqrt(r_hemi*r_hemi - distRight*distRight));
                }
                return Math.max(zL, zR);
            }
        };

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █ █ █   2. 计算引擎 (CALCULATION_ENGINE)   █ █ █
        // █ █ █   (v5 模型: c=x/4, 5x+...) - 只负责 "算" █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const CALCULATION_ENGINE = {
            getShapeParams: (shapeValue, x) => {
                const r_hemi = x / 4; // "计算" 模型的底座半径
                if (shapeValue < PIECEWISE_THRESHOLD) {
                    const shapeNorm = shapeValue / PIECEWISE_THRESHOLD;
                    const r_max = x * 100, r_min = r_hemi + 0.001; 
                    const r_A = r_max * Math.pow(r_min / r_max, shapeNorm);
                    return { r_A: r_A, y: 0, r_hemi: r_hemi }; // y=0
                } else {
                    const shapeNorm = (shapeValue - PIECEWISE_THRESHOLD) / (100 - PIECEWISE_THRESHOLD);
                    const y = shapeNorm * (x * 1.5); 
                    return { r_A: r_hemi, y: y, r_hemi: r_hemi }; // y>0, r_A=r_hemi
                }
            },
            calculateBustCircumference: (params, x) => {
                if (params.y === 0) { // '球面被切'
                    const { r_A, r_hemi } = params; // r_hemi = x/4
                    const arcLength = 2 * r_A * Math.asin( r_hemi / r_A );
                    return (5 * x) + (2 * arcLength);
                } else { // '圆柱+半球'
                    const { y } = params;
                    return (5 * x) + (2 * y) + (PI * x / 2);
                }
            }
        };

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █ █ █   3. 求解器 (SOLVER)   █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const SOLVER = {
            findShapeForCirc: (targetCirc, x) => {
                let minShape = 0;
                let maxShape = 100;
                let bestShape = 0;
                for (let i = 0; i < 15; i++) {
                    const midShape = (minShape + maxShape) / 2;
                    bestShape = midShape;
                    const params = CALCULATION_ENGINE.getShapeParams(midShape, x);
                    const currentCirc = CALCULATION_ENGINE.calculateBustCircumference(params, x);
                    if (currentCirc < targetCirc) {
                        minShape = midShape;
                    } else {
                        maxShape = midShape;
                    }
                }
                return bestShape;
            }
        };
        
        // ... (init() 函数保持不变) ...
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, TORSO_HEIGHT * 0.5, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambient);
            const light = new THREE.DirectionalLight(0xffffff, 2);
            light.position.set(10, 30, 50);
            scene.add(light);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, BUST_Y_POS, 0);
            controls.update();

            material = new THREE.MeshStandardMaterial({
                color: 0x008cff,
                roughness: 0.5,
                wireframe: false 
            });

            torsoGeo = new THREE.BoxGeometry(
                1, 1, 1, 
                SEGMENTS_W, SEGMENTS_H, SEGMENTS_D
            );
            originalPositions = torsoGeo.attributes.position.array.slice();

            torsoMesh = new THREE.Mesh(torsoGeo, material);
            scene.add(torsoMesh);

            underbustSlider.addEventListener('input', updateModel);
            bustCircSlider.addEventListener('input', updateModel);
            
            updateModel(); // 首次运行
            animate();
        }

        /**
         * 4. 统一的更新函数 (高性能)
         */
        function updateModel() {
            // --- 1. 读取输入: 下胸围 ---
            const underbust = parseFloat(underbustSlider.value);
            const x = underbust / 6.0; 
            const width = 2 * x;

            // --- 2. 约束上胸围滑块 ---
            const minBust = 6 * x; // 您的 5x+... 公式在 shape=0 时的极限
            bustCircSlider.min = minBust.toFixed(2); 

            // --- 3. 读取输入: 上胸围 (并约束) ---
            let targetBust = parseFloat(bustCircSlider.value);
            if (targetBust < minBust) {
                targetBust = minBust;
                bustCircSlider.value = targetBust;
            }
            
            // --- 4. 运行求解器 ---
            const foundShape = SOLVER.findShapeForCirc(targetBust, x);
            
            // --- 5. 驱动视觉 (v6 c=x 模型) ---
            const visualParams = VISUAL_ENGINE.getShapeParams(foundShape, x);
            
            // --- 6. 更新 3D 模型 (应用 "视觉") ---
            const positions = torsoGeo.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const base_ox = originalPositions[i];
                const base_oy = originalPositions[i + 1];
                const base_oz = originalPositions[i + 2];

                const ox = base_ox * width;
                const oy = base_oy * TORSO_HEIGHT;
                const oz = base_oz * x;
                let zOffset = 0;
                
                if (base_oz > 0.499) { 
                    zOffset = VISUAL_ENGINE.calculateDisplacement(ox, oy, x, width, visualParams);
                }
                
                positions[i] = ox;
                positions[i + 1] = oy;
                positions[i + 2] = oz + zOffset;
            }

            // --- 7. 通知 Three.js 更新 ---
            torsoGeo.attributes.position.needsUpdate = true;
            torsoGeo.computeVertexNormals();
            torsoGeo.computeBoundingSphere(); 

            // --- 8. !! JS 变更 !! 更新所有 UI 读数 ---
            
            // (获取 "计算" 引擎的参数用于显示)
            const mathParams = CALCULATION_ENGINE.getShapeParams(foundShape, x);

            document.getElementById('underbustValue').textContent = underbust.toFixed(0);
            document.getElementById('bustCircValue').textContent = targetBust.toFixed(2);
            
            // 调试 - 数学值
            document.getElementById('xValue').textContent = x.toFixed(2);
            document.getElementById('math_y').textContent = mathParams.y.toFixed(2);
            document.getElementById('math_r_A').textContent = mathParams.r_A.toFixed(2);
            
            // 调试 - 引擎状态
            document.getElementById('shapeValue').textContent = foundShape.toFixed(2);
            document.getElementById('modeValue').textContent = visualParams.mode; // (显示视觉模式)
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- 启动 ---
        init();
    </script>
</body>
</html>