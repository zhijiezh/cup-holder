<!DOCTYPE html>
<html>
<head>
    <title>统一模型 + 逆向求解 (v10 - 最终)</title>
    <style>
        /* 样式保持不变 */
        body { margin: 0; background-color: #111; color: white; }
        canvas { display: block; }
        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            font-family: sans-serif;
            min-width: 350px;
        }
        #controls label, #readouts div { 
            display: block; margin: 10px; 
        }
        #readouts {
            margin-top: 15px;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
        #readouts div {
            font-size: 1.1em;
            color: #8f0; 
        }
        #debug-readout {
            font-size: 0.8em; 
            color: #aaa; 
            line-height: 1.6;
        }
    </style>
</head>
<body>

    <div id="controls">
        <label for="themeSelector">主题风格:</label>
        <select id="themeSelector" style="width: 100%; padding: 5px; margin-bottom: 15px;"></select>

        <label for="underbust">下胸围 (cm): <span id="underbustValue">84</span></label>
        <input type="range" id="underbust" min="30" max="200" value="84" step="1">

        <label for="bustCirc">上胸围 (cm): <span id="bustCircValue">95.99</span></label>
        <input type="range" id="bustCirc" min="84" max="284" value="95.99" step="0.01">

        <div id="readouts">
            <div id="debug-readout">
                <b>统一数学值:</b><br>
                模式 = <span id="modeValue">...</span><br>
                x = <span id="xValue">...</span>, 
                y = <span id="yValue">...</span>, 
                r_A = <span id="r_AValue">...</span>
                <br>
                <b>引擎状态:</b> 求解 shape = <span id="shapeValue">...</span>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.skypack.dev/three@0.136.0/build/three.module.js",
        "three/controls/": "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/",
        "three/utils/": "https://cdn.skypack.dev/three@0.136.0/examples/jsm/utils/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/controls/OrbitControls.js';
        import { mergeBufferGeometries } from 'three/utils/BufferGeometryUtils.js';

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █   全局变量 & 状态管理
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        let scene, camera, renderer, controls;
        let meshes = {}; // 用一个对象来统一管理所有网格

        // 主题和材质管理
        const THEMES = {
            spongebob: {
                background: 0x87ceeb, // 天蓝色
                type: 'standard',
                structure: 'tri-part', // 三段式结构
                proportions: { shirt: 0.1, pants: 0.2 },
                body: { color: 0xffe44f, roughness: 0.8, metalness: 0.0 },
                shirt: { color: 0xffffff, roughness: 0.9, metalness: 0.0 },
                pants: { color: 0x966941, roughness: 0.9, metalness: 0.0 },
                eye: { color: 0xffffff, roughness: 0.2, metalness: 0.0 },
                pupil: { color: 0x000000, roughness: 0.0 },
            },
            classic: {
                background: 0x2a2a2a, // 深灰色
                type: 'standard',
                structure: 'uni-body', // 一体式结构
                proportions: { shirt: 0, pants: 0 },
                body: { color: 0x008cff, roughness: 0.5, metalness: 0.1 }, // 蓝色身体
                eye: { color: 0xffffff, roughness: 0.2, metalness: 0.0 }, // 改为白色眼球
                pupil: { color: 0x000000, roughness: 0.1 }, // 改为黑色瞳仁
            },
            toon: {
                background: 0xbde8ff, // 柔和天蓝
                type: 'toon',
                structure: 'tri-part', // 改为三段式
                proportions: { shirt: 0.25, pants: 0.35 }, // 衬衫+裤子比例
                body: { color: 0xffdab9 }, // 柔和肤色
                shirt: { color: 0xffdab9 }, // 改为与身体相同的肤色，实现无衬衫效果
                pants: { color: 0x4a6b96 }, // 牛仔蓝色
                eye: { color: 0xffffff, roughness: 0.1 }, // 保持白色，但让它更光滑以区别于衬衫
                pupil: { color: 0x222222 },
            },
            cyberpunk: {
                background: 0x12081a, // 深紫色
                type: 'standard',
                structure: 'tri-part',
                proportions: { shirt: 0.3, pants: 0.25 },
                body: { color: 0x333333, roughness: 0.4, metalness: 0.8 },
                shirt: { color: 0x222222, roughness: 0.5, metalness: 0.5, emissive: 0xff00ff, emissiveIntensity: 1.5 },
                pants: { color: 0x181818, roughness: 0.8, metalness: 0.2, emissive: 0x00ffff, emissiveIntensity: 1.5 },
                eye: { color: 0xffffff, emissive: 0xff00ff, roughness: 0.1, metalness: 0.1, emissiveIntensity: 2.5 },
                pupil: { color: 0xff00ff, emissive: 0xff00ff, emissiveIntensity: 3.0 },
            },
            alien: {
                background: 0x05020d, // 深空紫
                type: 'standard',
                structure: 'uni-body',
                proportions: { shirt: 0, pants: 0 },
                body: { color: 0x98fb98, roughness: 0.6, metalness: 0.1 }, // 浅绿色皮肤
                eye: { color: 0x0a0a0a, roughness: 0.05, metalness: 1.0 }, // 乌黑发亮的眼睛
                pupil: { color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 2.0 },
            }
        };

        const MATERIALS = {}; // 存放实例化的材质

        const THEME_MANAGER = {
            currentThemeName: 'spongebob',

            setTheme(themeName) {
                this.currentThemeName = themeName;
                const theme = THEMES[themeName] || THEMES.spongebob;
                setupMaterials(theme);
                setupLighting(theme);
                scene.background = new THREE.Color(theme.background);

                if (meshes.torsoTop) {
                    this.applyMaterials();
                    this.updateVisibility();
                    updateApp();
                }
            },

            updateAppearance(width, x) {
                const theme = THEMES[this.currentThemeName];
                if (theme.structure === 'tri-part') {
                    const shirtHeight = TORSO_HEIGHT * theme.proportions.shirt;
                    const pantsHeight = TORSO_HEIGHT * theme.proportions.pants;
                    const topHeight = TORSO_HEIGHT - shirtHeight - pantsHeight;

                    meshes.torsoTop.scale.set(width, topHeight, x);
                    meshes.torsoTop.position.y = (shirtHeight + pantsHeight) / 2;

                    meshes.torsoShirt.scale.set(width, shirtHeight, x);
                    meshes.torsoShirt.position.y = (pantsHeight - topHeight) / 2;

                    meshes.torsoPants.scale.set(width, pantsHeight, x);
                    meshes.torsoPants.position.y = (-topHeight - shirtHeight) / 2;
                } else { 
                    meshes.torsoTop.scale.set(width, TORSO_HEIGHT, x);
                    meshes.torsoTop.position.y = 0;

                    meshes.torsoShirt.scale.set(0, 0, 0);
                    meshes.torsoPants.scale.set(0, 0, 0);
                }
            },
            applyMaterials() {
                meshes.torsoTop.material = MATERIALS.body;
                meshes.torsoShirt.material = MATERIALS.shirt;
                meshes.torsoPants.material = MATERIALS.pants;
                meshes.leftEyeball.material = meshes.rightEyeball.material = MATERIALS.eye; // 注意: Eyeball 和 Pupil 的材质是分开的
                meshes.leftPupil.material = meshes.rightPupil.material = MATERIALS.pupil;
            },
            updateVisibility() {
                const theme = THEMES[this.currentThemeName];
                const isTriPart = theme.structure === 'tri-part';

                meshes.torsoShirt.visible = isTriPart;
                meshes.torsoPants.visible = isTriPart;
            }
        };

        const DOM = {
            themeSelector: document.getElementById('themeSelector'),
            underbustSlider: document.getElementById('underbust'),
            bustCircSlider: document.getElementById('bustCirc'),
            underbustValue: document.getElementById('underbustValue'),
            bustCircValue: document.getElementById('bustCircValue'),
            modeValue: document.getElementById('modeValue'),
            xValue: document.getElementById('xValue'),
            yValue: document.getElementById('yValue'),
            r_AValue: document.getElementById('r_AValue'),
            shapeValue: document.getElementById('shapeValue'),
        };

        // 常量
        const TORSO_HEIGHT = 40; 
        const SEGMENTS_W = 1, SEGMENTS_H = 1, SEGMENTS_D = 1; 
        const BUST_Y_POS = TORSO_HEIGHT * 0.25;
        const PIECEWISE_THRESHOLD = 50; 
        const PI = Math.PI;

        // 应用状态
        const APP_STATE = {
            underbust: 84,
            targetBust: 95.99,
            foundShape: 0,
        };

        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █   1. 统一的几何引擎 (GEOMETRY_ENGINE)
        // █ █ █   (v10 模型: c=x, r_hemi=x/2, 5x+...)  █ █ █
        // █ █ █   视觉 和 数学 100% 统一            █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const GEOMETRY_ENGINE = {
            
            /**
             * 1. 核心塑形函数 (视觉 + 数学)
             * !! 关键改动: 统一 r_hemi = x/2 !!
             */
            getShapeParams: (shapeValue, x) => {
                const r_hemi = x / 2; // "统一" 模型的底座半径
                
                if (shapeValue < PIECEWISE_THRESHOLD) {
                    // --- 方案A: "球面被切" (c=x) ---
                    const shapeNorm = shapeValue / PIECEWISE_THRESHOLD;
                    const r_max = x * 100; // "很平"
                    const r_min = r_hemi + 0.001; 
                    const r_A = r_max * Math.pow(r_min / r_max, shapeNorm);
                    const h = r_A - Math.sqrt(r_A * r_A - r_hemi * r_hemi);
                    return { 
                        mode: '球面 (c=x)', 
                        r_A: r_A, h: h, y: 0, r_hemi: r_hemi 
                    };
                } else {
                    // --- 方案B: "圆柱+半球" (c=x) ---
                    const shapeNorm = (shapeValue - PIECEWISE_THRESHOLD) / (100 - PIECEWISE_THRESHOLD);
                    const y_max = x * 1.5;
                    const y = shapeNorm * y_max;
                    const h = y + r_hemi;
                    return { 
                        mode: '圆柱 (c=x)', 
                        r_A: r_hemi, h: h, y: y, r_hemi: r_hemi 
                    };
                }
            },

            /**
             * 3. 精确测量函数 (数学)
             * !! 关键改动: 统一的 v10 公式 !!
             */
            calculateBustCircumference: (params, x) => {
                if (params.y === 0) { // '球面被切'
                    const { r_A, r_hemi } = params; // r_hemi = x/2
                    // 您的公式 (A): 5x + (1 * 弧长)
                    // 弧长 = 2 * r_A * asin( (x/2) / r_A ) = 2 * r_A * asin(r_hemi / r_A)
                    const arcLength = 2 * r_A * Math.asin( r_hemi / r_A );
                    return (5 * x) + arcLength; // 修正: 是 1 倍弧长
                } else { // '圆柱+半球'
                    const { y } = params;
                    // 您的公式 (B): 5x + 2y + PI*x/2
                    return (5 * x) + (2 * y) + (PI * x / 2);
                }
            }
        };

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █   2. 求解器 (SOLVER)
        // █ █ █   (与 v9 相同, 但现在调用统一的引擎) █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const SOLVER = {
            findShapeForCirc: (targetCirc, x) => {
                let minShape = 0;
                let maxShape = 100;
                let bestShape = 0;
                for (let i = 0; i < 15; i++) {
                    const midShape = (minShape + maxShape) / 2;
                    bestShape = midShape;
                    
                    // !! 关键: 调用统一的引擎 !!
                    const params = GEOMETRY_ENGINE.getShapeParams(midShape, x);
                    const currentCirc = GEOMETRY_ENGINE.calculateBustCircumference(params, x);

                    if (currentCirc < targetCirc) {
                        minShape = midShape;
                    } else {
                        maxShape = midShape;
                    }
                }
                return bestShape;
            }
        };
        
        /**
         * 主更新函数，负责协调所有更新
         */
        function updateApp() {
            updateStateFromUI();
            const params = updateGeometries();
            updateUIDisplay(params);
        }

        /**
         * 从UI滑块读取输入并更新应用状态
         */
        function updateStateFromUI() {
            APP_STATE.underbust = parseFloat(DOM.underbustSlider.value);

            // 约束上胸围滑块范围
            const minBust = APP_STATE.underbust;
            const maxBust = APP_STATE.underbust + 200;
            DOM.bustCircSlider.min = minBust.toFixed(2);
            DOM.bustCircSlider.max = maxBust.toFixed(2);

            // 读取并约束上胸围值
            let targetBust = parseFloat(DOM.bustCircSlider.value);
            APP_STATE.targetBust = Math.max(minBust, Math.min(targetBust, maxBust));

            // 运行求解器
            const x = APP_STATE.underbust / 6.0;
            APP_STATE.foundShape = SOLVER.findShapeForCirc(APP_STATE.targetBust, x);
        }

        /**
         * 根据当前状态更新所有3D几何体
         */
        function updateGeometries() {
            const x = APP_STATE.underbust / 6.0;
            const width = 2 * x;
            const halfDepth = x / 2;

            // 获取统一参数
            const params = GEOMETRY_ENGINE.getShapeParams(APP_STATE.foundShape, x);

            // --- 更新眼睛几何体 (眼球+瞳仁) ---
            const BUST_X_POS = width * 0.25;
            let bustGeo;

            if (params.mode === '圆柱 (c=x)') {
                // --- 大胸模式: 使用独立的几何体 ---
                const { y, r_hemi } = params;

                // a. 创建圆柱和半球
                const cylinderGeo = new THREE.CylinderGeometry(r_hemi, r_hemi, y, 32);
                const sphereGeo = new THREE.SphereGeometry(r_hemi, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                
                // b. 定位并合并
                cylinderGeo.translate(0, y / 2, 0);
                sphereGeo.translate(0, y, 0);
                bustGeo = mergeBufferGeometries([cylinderGeo, sphereGeo]);
                
                // c. 旋转使其朝向前方 (Z轴)
                bustGeo.rotateX(Math.PI / 2);

            } else {
                // 小胸模式: 使用球帽几何体
                const { r_A, r_hemi, h } = params;
                
                // 计算球帽的角度
                const thetaLength = Math.asin(r_hemi / r_A);

                // b. 创建球帽几何体
                bustGeo = new THREE.SphereGeometry(r_A, 32, 16, 0, Math.PI * 2, 0, thetaLength);
                
                // c. 旋转并定位，使其底部与身体表面对齐
                bustGeo.rotateX(Math.PI / 2); // 使其朝向前方 (Z轴)
                bustGeo.translate(0, 0, -(r_A - h)); // 将球帽的"底面"移动到 Z=0 平面
            }

            // 更新眼球
            meshes.leftEyeball.geometry.dispose();
            meshes.rightEyeball.geometry.dispose();
            meshes.leftEyeball.geometry = bustGeo;
            meshes.rightEyeball.geometry = bustGeo.clone();

            // 更新瞳仁 (平面)
            const pupilRadius = params.r_hemi * 0.4;
            const pupilGeo = new THREE.CircleGeometry(pupilRadius, 16);
            meshes.leftPupil.geometry.dispose();
            meshes.rightPupil.geometry.dispose();
            meshes.leftPupil.geometry = pupilGeo; // 左瞳仁
            meshes.rightPupil.geometry = pupilGeo.clone(); // 右瞳仁
            
            // 定位瞳仁在眼球表面
            const pupilZOffset = params.h + 0.1; // 稍微向前偏移以防止渲染冲突 (Z-fighting)
            meshes.leftPupil.position.z = pupilZOffset;
            meshes.rightPupil.position.z = pupilZOffset;

            // --- 更新躯干外观 (委托给主题管理器) ---
            THEME_MANAGER.updateAppearance(width, x);

            // 定位整个眼睛 Group
            meshes.leftEyeGroup.position.set(-BUST_X_POS, BUST_Y_POS, halfDepth);
            meshes.rightEyeGroup.position.set(BUST_X_POS, BUST_Y_POS, halfDepth); // 修复: 右眼应该在正X轴

            return params; // 将参数传出给UI更新函数
        }

        /**
         * 根据计算结果更新页面上的所有文本读数
         */
        function updateUIDisplay(params) {
            DOM.underbustValue.textContent = APP_STATE.underbust.toFixed(0);
            DOM.bustCircValue.textContent = APP_STATE.targetBust.toFixed(2);
            
            DOM.modeValue.textContent = params.mode;
            DOM.xValue.textContent = (APP_STATE.underbust / 6.0).toFixed(2);
            DOM.yValue.textContent = params.y.toFixed(2);
            DOM.r_AValue.textContent = params.r_A.toFixed(2);
            DOM.shapeValue.textContent = APP_STATE.foundShape.toFixed(2);
        }

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █   初始化 & 渲染循环
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        function setupScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, TORSO_HEIGHT * 0.5, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, BUST_Y_POS, 0);
        }

        function setupLighting(theme) {
            // 清理旧灯光
            scene.children.filter(obj => obj.isLight).forEach(light => scene.remove(light));

            if (theme.type === 'toon') {
                const light = new THREE.HemisphereLight(0xffffff, 0x444444, 2.5);
                light.position.set(0, 100, 0);
                scene.add(light);
            } else {
                const ambient = new THREE.AmbientLight(0x404040, 2);
                const light = new THREE.DirectionalLight(0xffffff, 2);
                light.position.set(10, 30, 50);
                scene.add(ambient, light);
            }
        }

        function setupMaterials(theme) {
            const MaterialClass = theme.type === 'toon' ? THREE.MeshToonMaterial : THREE.MeshStandardMaterial;

            for (const key of ['body', 'shirt', 'pants', 'eye', 'pupil']) {
                if (theme[key]) {
                    const props = { ...theme[key] };
                    // 关键修复: 瞳仁是平面，需要渲染双面
                    if (key === 'pupil') props.side = THREE.DoubleSide;
                    MATERIALS[key] = new MaterialClass(props);
                }
            }
        }

        function setupGeometry() {
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            meshes.torsoTop = new THREE.Mesh(boxGeo, MATERIALS.body);
            meshes.torsoShirt = new THREE.Mesh(boxGeo, MATERIALS.shirt);
            meshes.torsoPants = new THREE.Mesh(boxGeo, MATERIALS.pants);

            THEME_MANAGER.updateVisibility();

            // 创建眼睛 (眼球+瞳仁的组合)
            meshes.leftEyeGroup = new THREE.Group();
            meshes.rightEyeGroup = new THREE.Group();

            meshes.leftEyeball = new THREE.Mesh(new THREE.BufferGeometry(), MATERIALS.eye);
            meshes.rightEyeball = new THREE.Mesh(new THREE.BufferGeometry(), MATERIALS.eye);
            meshes.leftPupil = new THREE.Mesh(new THREE.CircleGeometry(1, 16), MATERIALS.pupil);
            meshes.rightPupil = new THREE.Mesh(new THREE.CircleGeometry(1, 16), MATERIALS.pupil);

            meshes.leftEyeGroup.add(meshes.leftEyeball, meshes.leftPupil);
            meshes.rightEyeGroup.add(meshes.rightEyeball, meshes.rightPupil);

            scene.add(
                meshes.torsoTop, meshes.torsoShirt, meshes.torsoPants,
                meshes.leftEyeGroup, meshes.rightEyeGroup
            );
        }

        function setupEventListeners() {
            const themeSelector = DOM.themeSelector;
            for (const themeName in THEMES) {
                const option = document.createElement('option');
                option.value = themeName;
                option.textContent = themeName.charAt(0).toUpperCase() + themeName.slice(1);
                themeSelector.appendChild(option);
            }
            themeSelector.value = THEME_MANAGER.currentThemeName;

            themeSelector.addEventListener('change', (event) => {
                THEME_MANAGER.setTheme(event.target.value);
            });

            DOM.underbustSlider.addEventListener('input', updateApp);
            DOM.bustCircSlider.addEventListener('input', updateApp);
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function init() {
            setupScene();
            THEME_MANAGER.setTheme('spongebob'); // 设置初始主题
            setupGeometry();
            setupEventListeners();
            updateApp(); // 关键修复: 在所有设置完成后，手动调用一次，以确保初始状态正确
            animate();
        }

        init();
    </script>
</body>
</html>