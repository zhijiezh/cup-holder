<!DOCTYPE html>
<html>
<head>
    <title>统一模型 + 逆向求解 (v10 - 最终)</title>
    <style>
        /* 样式保持不变 */
        body { margin: 0; background-color: #111; color: white; }
        canvas { display: block; }
        #controls {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            font-family: sans-serif;
            min-width: 350px;
        }
        #controls label, #readouts div { 
            display: block; margin: 10px; 
        }
        #readouts {
            margin-top: 15px;
            border-top: 1px solid #555;
            padding-top: 10px;
        }
        #readouts div {
            font-size: 1.1em;
            color: #8f0; 
        }
        #debug-readout {
            font-size: 0.8em; 
            color: #aaa; 
            line-height: 1.6;
        }
    </style>
</head>
<body>

    <div id="controls">
        <label for="underbust">下胸围 (cm): <span id="underbustValue">84</span></label>
        <input type="range" id="underbust" min="60" max="120" value="84" step="1">

        <label for="bustCirc">上胸围 (cm): <span id="bustCircValue">95.99</span></label>
        <input type="range" id="bustCirc" min="84" max="160" value="95.99" step="0.01">

        <div id="readouts">
            <div id="debug-readout">
                <b>统一数学值:</b><br>
                模式 = <span id="modeValue">...</span><br>
                x = <span id="xValue">...</span>, 
                y = <span id="yValue">...</span>, 
                r_A = <span id="r_AValue">...</span>
                <br>
                <b>引擎状态:</b> 求解 shape = <span id="shapeValue">...</span>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.skypack.dev/three@0.128.0/build/three.module.js",
        "three/controls/": "https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/controls/OrbitControls.js';

        let scene, camera, renderer, controls, material, torsoMesh, torsoGeo;
        let originalPositions; 

        // DOM 元素
        const underbustSlider = document.getElementById('underbust');
        const bustCircSlider = document.getElementById('bustCirc');

        // 常量
        const TORSO_HEIGHT = 40; 
        const SEGMENTS_W = 32, SEGMENTS_H = 48, SEGMENTS_D = 16; 
        const BUST_Y_POS = TORSO_HEIGHT * 0.25;
        const PIECEWISE_THRESHOLD = 50; 
        const PI = Math.PI;

        
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █ █ █   1. 统一的几何引擎 (GEOMETRY_ENGINE)   █ █ █
        // █ █ █   (v10 模型: c=x, r_hemi=x/2, 5x+...)  █ █ █
        // █ █ █   视觉 和 数学 100% 统一            █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const GEOMETRY_ENGINE = {
            
            /**
             * 1. 核心塑形函数 (视觉 + 数学)
             * !! 关键改动: 统一 r_hemi = x/2 !!
             */
            getShapeParams: (shapeValue, x) => {
                const r_hemi = x / 2; // "统一" 模型的底座半径
                
                if (shapeValue < PIECEWISE_THRESHOLD) {
                    // --- 方案A: "球面被切" (c=x) ---
                    const shapeNorm = shapeValue / PIECEWISE_THRESHOLD;
                    const r_max = x * 100; // "很平"
                    const r_min = r_hemi + 0.001; 
                    const r_A = r_max * Math.pow(r_min / r_max, shapeNorm);
                    const h = r_A - Math.sqrt(r_A * r_A - r_hemi * r_hemi);
                    return { 
                        mode: '球面 (c=x)', 
                        r_A: r_A, h: h, y: 0, r_hemi: r_hemi 
                    };
                } else {
                    // --- 方案B: "圆柱+半球" (c=x) ---
                    const shapeNorm = (shapeValue - PIECEWISE_THRESHOLD) / (100 - PIECEWISE_THRESHOLD);
                    const y_max = x * 1.5;
                    const y = shapeNorm * y_max;
                    const h = y + r_hemi;
                    return { 
                        mode: '圆柱 (c=x)', 
                        r_A: r_hemi, h: h, y: y, r_hemi: r_hemi 
                    };
                }
            },

            /**
             * 2. 顶点位移函数 (视觉)
             * (这是 v6 "核心正确" 的视觉)
             */
            calculateDisplacement: (ox, oy, x, width, params) => {
                const BUST_X_POS = width * 0.25; // x/2
                const leftCenter = { x: -BUST_X_POS, y: BUST_Y_POS };
                const rightCenter = { x: BUST_X_POS, y: BUST_Y_POS };
                
                const distLeft = Math.hypot(ox - leftCenter.x, oy - leftCenter.y);
                const distRight = Math.hypot(ox - rightCenter.x, oy - rightCenter.y);
                let zL = 0, zR = 0;
                
                if (params.y === 0) { // '球面被切'
                    const { r_A, h, r_hemi } = params;
                    if (distLeft < r_hemi) zL = Math.sqrt(r_A*r_A - distLeft*distLeft) - r_A + h;
                    if (distRight < r_hemi) zR = Math.sqrt(r_A*r_A - distRight*distRight) - r_A + h;
                } else { // '圆柱+半球'
                    const { y, r_hemi } = params;
                    if (distLeft < r_hemi) zL = y + (Math.sqrt(r_hemi*r_hemi - distLeft*distLeft));
                    if (distRight < r_hemi) zR = y + (Math.sqrt(r_hemi*r_hemi - distRight*distRight));
                }
                return Math.max(zL, zR);
            },

            /**
             * 3. 精确测量函数 (数学)
             * !! 关键改动: 统一的 v10 公式 !!
             */
            calculateBustCircumference: (params, x) => {
                if (params.y === 0) { // '球面被切'
                    const { r_A, r_hemi } = params; // r_hemi = x/2
                    // 您的公式 (A): 5x + (1 * 弧长)
                    // 弧长 = 2 * r_A * asin( (x/2) / r_A ) = 2 * r_A * asin(r_hemi / r_A)
                    const arcLength = 2 * r_A * Math.asin( r_hemi / r_A );
                    return (5 * x) + arcLength; // 修正: 是 1 倍弧长
                } else { // '圆柱+半球'
                    const { y } = params;
                    // 您的公式 (B): 5x + 2y + PI*x/2
                    return (5 * x) + (2 * y) + (PI * x / 2);
                }
            }
        };

        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        // █ █ █   2. 求解器 (SOLVER)   █ █ █
        // █ █ █   (与 v9 相同, 但现在调用统一的引擎) █ █ █
        // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
        const SOLVER = {
            findShapeForCirc: (targetCirc, x) => {
                let minShape = 0;
                let maxShape = 100;
                let bestShape = 0;
                for (let i = 0; i < 15; i++) {
                    const midShape = (minShape + maxShape) / 2;
                    bestShape = midShape;
                    
                    // !! 关键: 调用统一的引擎 !!
                    const params = GEOMETRY_ENGINE.getShapeParams(midShape, x);
                    const currentCirc = GEOMETRY_ENGINE.calculateBustCircumference(params, x);

                    if (currentCirc < targetCirc) {
                        minShape = midShape;
                    } else {
                        maxShape = midShape;
                    }
                }
                return bestShape;
            }
        };
        
        // ... (init() 函数保持不变) ...
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, TORSO_HEIGHT * 0.5, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambient);
            const light = new THREE.DirectionalLight(0xffffff, 2);
            light.position.set(10, 30, 50);
            scene.add(light);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, BUST_Y_POS, 0);
            controls.update();

            material = new THREE.MeshStandardMaterial({
                color: 0x008cff,
                roughness: 0.5,
                wireframe: false 
            });

            torsoGeo = new THREE.BoxGeometry(
                1, 1, 1, 
                SEGMENTS_W, SEGMENTS_H, SEGMENTS_D
            );
            originalPositions = torsoGeo.attributes.position.array.slice();

            torsoMesh = new THREE.Mesh(torsoGeo, material);
            scene.add(torsoMesh);

            underbustSlider.addEventListener('input', updateModel);
            bustCircSlider.addEventListener('input', updateModel);
            
            updateModel(); // 首次运行
            animate();
        }


        /**
         * 4. 统一的更新函数 (高性能)
         * !! 关键改动: 统一引擎 !!
         */
        function updateModel() {
            // --- 1. 读取输入: 下胸围 ---
            const underbust = parseFloat(underbustSlider.value);
            const x = underbust / 6.0; 
            const width = 2 * x;

            // --- 2. 约束上胸围滑块 ---
            // 极限 (shape=0) 必须用引擎计算 (lim(r->inf) 2*r*asin(x/2r) = x)
            // (5x + x = 6x)
            const params_0 = GEOMETRY_ENGINE.getShapeParams(0, x);
            const minBust = GEOMETRY_ENGINE.calculateBustCircumference(params_0, x);
            bustCircSlider.min = minBust.toFixed(2); 

            // (计算最大值)
            const params_100 = GEOMETRY_ENGINE.getShapeParams(100, x);
            const maxBust = GEOMETRY_ENGINE.calculateBustCircumference(params_100, x);
            bustCircSlider.max = maxBust.toFixed(2);

            // --- 3. 读取输入: 上胸围 (并约束) ---
            let targetBust = parseFloat(bustCircSlider.value);
            if (targetBust < minBust) targetBust = minBust;
            if (targetBust > maxBust) targetBust = maxBust;
            
            // --- 4. 运行求解器 ---
            const foundShape = SOLVER.findShapeForCirc(targetBust, x);
            
            // --- 5. !! 核心: 统一驱动 !! ---
            // 用求解出的 shape, 获取 统一的 参数
            const params = GEOMETRY_ENGINE.getShapeParams(foundShape, x);
            
            // --- 6. 更新 3D 模型 (应用 "统一" 参数) ---
            const positions = torsoGeo.attributes.position.array;
            const cornerRadius = x * 0.15; // 圆角半径，设置为一个较小的值
            const halfWidth = width / 2;
            const halfDepth = x / 2;

            for (let i = 0; i < positions.length; i += 3) {
                const base_ox = originalPositions[i];
                const base_oy = originalPositions[i + 1];
                const base_oz = originalPositions[i + 2];

                let ox = base_ox * width;
                const oy = base_oy * TORSO_HEIGHT;
                let oz = base_oz * x;
                
                const original_ox_for_bust = ox; // 为计算胸部形状，保留原始ox

                // --- 圆角逻辑开始 ---
                // 只处理长方体在XZ平面的四个垂直角
                if (Math.abs(ox) > halfWidth - cornerRadius && Math.abs(oz) > halfDepth - cornerRadius) {
                    const cornerCenterX = Math.sign(ox) * (halfWidth - cornerRadius);
                    const cornerCenterZ = Math.sign(oz) * (halfDepth - cornerRadius);
                    
                    const vecX = ox - cornerCenterX;
                    const vecZ = oz - cornerCenterZ;
                    const len = Math.hypot(vecX, vecZ);

                    if (len > 0) {
                        // 将顶点拉到圆角弧线上
                        ox = cornerCenterX + (vecX / len) * cornerRadius;
                        oz = cornerCenterZ + (vecZ / len) * cornerRadius;
                    }
                }
                // --- 圆角逻辑结束 ---

                let zOffset = 0;
                // 只在身体正面应用胸部突起
                if (base_oz > 0.499) { 
                    // 使用原始的ox坐标来计算位移，以保证胸部形状不受圆角影响
                    zOffset = GEOMETRY_ENGINE.calculateDisplacement(original_ox_for_bust, oy, x, width, params);
                }
                
                positions[i] = ox;
                positions[i + 1] = oy;
                positions[i + 2] = oz + zOffset;
            }

            // --- 7. 通知 Three.js 更新 ---
            torsoGeo.attributes.position.needsUpdate = true;
            torsoGeo.computeVertexNormals();
            torsoGeo.computeBoundingSphere(); 

            // --- 8. 更新所有 UI 读数 ---
            document.getElementById('underbustValue').textContent = underbust.toFixed(0);
            document.getElementById('bustCircValue').textContent = targetBust.toFixed(2);
            
            // 调试 - 数学值
            document.getElementById('modeValue').textContent = params.mode;
            document.getElementById('xValue').textContent = x.toFixed(2);
            document.getElementById('yValue').textContent = params.y.toFixed(2);
            document.getElementById('r_AValue').textContent = params.r_A.toFixed(2);
            document.getElementById('shapeValue').textContent = foundShape.toFixed(2);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- 启动 ---
        init();
    </script>
</body>
</html>